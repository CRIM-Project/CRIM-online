'use strict';

var _namespace = require('../utils/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $ = global.jQuery = require('jquery');
require('../../../lib/jquery-xpath/jquery.xpath');

var meiprocessing = {};

meiprocessing.getClosestMeter = function () {
    var XPevent = this;
    var XPscoreDef = XPevent.xpath("preceding::mei:scoreDef[1]", _namespace2.default);

    // Process for beat data if the scoreDef defines meter, otherwise lookback
    var count = XPscoreDef.attr("meter.count");
    var unit = XPscoreDef.attr("meter.unit");
    if (!count || !unit) {
        var count_elm = XPscoreDef.xpath("descendant::mei:meterSig", _namespace2.default);
        if (count_elm.length > 0) {
            if (count_elm.length > 1) {
                throw "Mixed meter is not supported";
            }
            var _count = count_elm[0].xpath("@count").val();
            var _unit = count_elm[0].xpath("@unit").val();
            if (!_count || !_unit) {
                throw "Could not locate meter and compute beats";
            }
        }
        // No meter specified, lookback
        else {
                return meiprocessing.getClosestMeter.apply(XPscoreDef);
            }
    }
    return { "count": count, "unit": unit };
};

meiprocessing.getDurationToMeter = function () {
    var XPevent = this;

    if (XPevent.xpath("self::mei:mRest", _namespace2.default).length > 0) {
        return "all";
    } else {
        var dur = XPevent.xpath("@dur").val();
        if (!dur) {
            throw "Element has no duration.";
        }
        var dots = 0;
        if (dur == "breve") {
            dur = 0.5;
        } else if (dur == "long") {
            dur = 0.25;
        }
        dur = Number(dur);
        var attr = XPevent.xpath("@dots").val();
        var els = XPevent.xpath("dot");
        if (attr) {
            dots = parseInt(attr);
        } else if (els) {
            dots = els.length;
        }

        // Calculate duration relative to meter
        var meter = meiprocessing.getClosestMeter.apply(this);
        var relative_dur = meter.unit / dur;

        var dot_dur = dur;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from(new Array(dots), function (x, i) {
                return i;
            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var d = _step.value;

                dot_dur = dot_dur * 2;
                relative_dur += meter.unit / dot_dur;
            }

            // Adjust duration if this event is contained in a tuplet
            // TODO: deal with teupletspan
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        var XPtupl = XPevent.xpath("ancestor::mei:tuplet", _namespace2.default);
        if (XPtupl.length > 0) {
            var numbase = XPtupl.xpath("@numbase");
            var num = XPtupl.xpath("@num");

            if (!num || !numbase) {
                throw "Cannot understand tuplet beat: both @num and @numbase must be present";
            } else {
                var tupl_ratio = parseFloat(numbase.val()) / parseFloat(num.val());
                relative_dur = relative_dur * tupl_ratio;
            }
        }

        return relative_dur;
    }
};

meiprocessing.getEventBeat = function () {
    var XPevent = this;

    if (XPevent.xpath("self::mei:mRest", _namespace2.default).length > 0) {
        return "all";
    } else {
        var dur = XPevent.xpath("@dur").val();
        if (!dur) {
            throw "Element has no duration.";
        }

        var beat = 1.0;

        // This is a bit inefficient because xpath.js doesn't support generate-id().
        var XPstaff = XPevent.xpath("ancestor::mei:staff[1]", _namespace2.default);
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = XPstaff.xpath("descendant::*[@dur][not(@grace)]")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var el = _step2.value;

                var $el = $(el);
                if ($el.attr("xml:id") == XPevent.attr("xml:id")) {
                    break;
                }
                beat += meiprocessing.getDurationToMeter.apply($el);
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        return parseFloat(beat.toFixed(4));
    }
};

$.extend($.prototype, meiprocessing);